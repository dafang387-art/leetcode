知识点：
（1）在c++中，>>1是右移一位，表示当前数字/2
（2）要有问题精炼化的能力，这里Leetcode官方的题解就不错：
考虑这个插入的位置 pos，它成立的条件为：nums[pos−1]<target≤nums[pos]
其中 nums 代表排序数组。由于如果存在这个目标值，我们返回的索引也是 pos，因此我们可以将两个条件合并得出最后的目标：「在一个有序数组中找第一个大于等于 target 的下标」。

解法A：暴力：
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        for (int i = 0; i < nums.size(); i++) {
        // 分别处理如下三种情况
        // 目标值在数组所有元素之前
        // 目标值等于数组中某一个元素
        // 目标值插入数组中的位置
            if (nums[i] >= target) { // 一旦发现大于或者等于target的num[i]，那么i就是我们要的结果
                return i;
            }
        }
        // 目标值在数组所有元素之后的情况
        return nums.size(); // 如果target是最大的，或者 nums为空，则返回nums的长度
    }
};


解法B:class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int left=0;
        int right=nums.size()-1;
        while(left<=right){
            int mid = (right-left)/2 + left;
            int num = nums[mid];
            if(num == target){
                return mid;
            }else if(num<target){
                left = mid + 1;
            }else if(num>target){
                right = mid - 1;
            }
        }
        return left;
    }
};
